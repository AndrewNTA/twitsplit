{"version":3,"sources":["src/utils.js"],"names":["chunkMessage","msg","lengthMsg","length","forecastNumber","forecastNumberDigitsOfMaxSplitMsg","error","spaceIndexArr","i","push","handleSplit","result","theFirstIndex","getIndexSplit","theFirstMsg","substring","temp","count","numberDigitsOfCount","toString","tempMsg","tempPivot","findIndexMsg","expectedResult","map","index","indicator","concat","correctlyResult","verifyResultCorrectly","arr","pivot","tempIndex","findIndex","e"],"mappings":"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","file":"utils.2d7aa781.js","sourceRoot":"..","sourcesContent":["function chunkMessage(msg) {\n  const lengthMsg = msg.length;\n  if (lengthMsg <= 50) {\n    // Does not split this message\n    return [msg];\n  } else {\n    // Handle to split this message\n    // Forecast the number of digits of the max section will be split\n    let forecastNumber = forecastNumberDigitsOfMaxSplitMsg(lengthMsg);\n    if (!forecastNumber) {\n      return { error: \"Message is over the max length\" };\n    }\n    // Store all index of whitespace of this string message\n    const spaceIndexArr = [];\n    for (let i = 0; i < lengthMsg; i++) {\n      if (msg[i] === \" \") {\n        spaceIndexArr.push(i);\n      }\n    }\n    return handleSplit(msg, spaceIndexArr, lengthMsg, forecastNumber);\n  }\n}\n\nfunction handleSplit(msg, spaceIndexArr, lengthMsg, forecastNumber) {\n  const result = [];\n  // Handle the first message\n  const theFirstIndex = getIndexSplit(spaceIndexArr, 47 - forecastNumber);\n  const theFirstMsg = msg.substring(0, theFirstIndex);\n  result.push(theFirstMsg);\n  let temp = theFirstIndex;\n  let count = 1;\n  // Iterator to get all message sections\n  while (temp < lengthMsg) {\n    count++;\n    const numberDigitsOfCount = count.toString().length;\n    let tempMsg = \"\";\n    // Find the location should be split\n    const tempPivot = temp + (49 - numberDigitsOfCount - forecastNumber);\n    // The last message section will be push to result\n    if (tempPivot > lengthMsg) {\n      tempMsg = msg.substring(temp, lengthMsg);\n      result.push(tempMsg);\n      break;\n    }\n    // Find index of whitespace to split\n    const findIndexMsg = getIndexSplit(spaceIndexArr, tempPivot);\n    // Through an error when total characters of indicator and message is greater than 50\n    if (temp === findIndexMsg) {\n      return { error: \"Has an error !!!\" };\n    }\n    tempMsg = msg.substring(temp, findIndexMsg);\n    result.push(tempMsg);\n    temp = findIndexMsg;\n  }\n  const expectedResult = result.map((msg, index) => {\n    // Append the indicator\n    if (index === 0) {\n      const indicator = `${index + 1}/${count} `;\n      return indicator.concat(msg);\n    }\n    const indicator = `${index + 1}/${count}`;\n    return indicator.concat(msg);\n  });\n\n  // Verify the result of split message\n  const correctlyResult = verifyResultCorrectly(expectedResult);\n  if (!correctlyResult) {\n    // Loops again to make sure the result is correct\n    return handleSplit(msg, spaceIndexArr, lengthMsg, forecastNumber + 1);\n  }\n  return expectedResult;\n}\n\nfunction verifyResultCorrectly(result) {\n  for (let i = 0; i < result.length; i++) {\n    if (result[i].length > 50) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getIndexSplit(arr, pivot) {\n  const tempIndex = arr.findIndex(e => e > pivot);\n  if (arr[arr.length - 1] <= pivot) {\n    return arr[arr.length - 1];\n  }\n  return arr[tempIndex - 1];\n}\n\nfunction forecastNumberDigitsOfMaxSplitMsg(lengthMsg) {\n  if (lengthMsg <= 422) {\n    return 1;\n  } else if (lengthMsg <= 4463) {\n    return 2;\n  } else if (lengthMsg <= 42000) {\n    return 3;\n  } else {\n    return 0;\n  }\n}\n\nexport default chunkMessage;\n"]}